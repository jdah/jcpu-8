package net.jonathan.emulator;

import java.awt.*;
import java.util.HashMap;

public class PiInterface
{

	private HashMap<Integer, Sprite> spriteMap = new HashMap<>();
	private boolean[] usedSpriteIDs = new boolean[256];

	private int boundSprite = 0xFF;
	private boolean boundSpriteExists = false;

	private int pixelUploadX;
	private int pixelUploadY;

	private boolean isNextTranslateNegative = false;

	private short addressHigh;
	private short addressLow;

	private GraphicsPanel panel;
	private PiKeyboardListener keyboardListener;
	private StorageController storageController;

	/* Characters that will be pre-uploaded to the Raspberry Pi (8x8) */
	private static final int[][] initChars = new int[][]
	{
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0000 (nul)
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0001
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0002
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0003
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0004
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0005
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0006
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0007
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0008
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0009
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000A
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000B
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000C
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000D
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000E
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000F
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0010
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0011
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0012
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0013
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0014
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0015
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0016
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0017
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0018
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0019
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001A
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001B
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001C
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001D
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001E
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001F
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
		{ 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
		{ 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
		{ 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
		{ 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
		{ 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
		{ 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
		{ 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
		{ 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
		{ 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
		{ 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
		{ 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
		{ 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
		{ 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
		{ 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
		{ 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
		{ 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
		{ 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
		{ 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
		{ 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
		{ 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
		{ 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
		{ 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
		{ 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
		{ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
		{ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (//)
		{ 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
		{ 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
		{ 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
		{ 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
		{ 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
		{ 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
		{ 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
		{ 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
		{ 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
		{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
		{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
		{ 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
		{ 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
		{ 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
		{ 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
		{ 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
		{ 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
		{ 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
		{ 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
		{ 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
		{ 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
		{ 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
		{ 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
		{ 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
		{ 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
		{ 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
		{ 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
		{ 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
		{ 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
		{ 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
		{ 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
		{ 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
		{ 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
		{ 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
		{ 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
		{ 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
		{ 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
		{ 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
		{ 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
		{ 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
		{ 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
		{ 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
		{ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
		{ 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
		{ 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
		{ 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
		{ 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
		{ 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
		{ 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
		{ 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
		{ 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
		{ 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
		{ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
		{ 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
		{ 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
		{ 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
		{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
		{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
		{ 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
		{ 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
		{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
		{ 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
		{ 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B
		{ 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
		{ 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D
		{ 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+007F
	};

	public PiInterface(GraphicsPanel panel, PiKeyboardListener keyboardListener, StorageController storageController)
	{
		this.panel = panel;
		this.keyboardListener = keyboardListener;
		this.storageController = storageController;

		/* Upload the default character sprites */
		for(int i = 0; i < initChars.length; i++)
		{
			usedSpriteIDs[i] = true;
			int[] currentChar = initChars[i];

			Sprite charSprite = new Sprite(this.panel);

			for(int j = 0; j < currentChar.length; j++)
			{
				byte row = (byte) (currentChar[j] & 0xFF);

				/* Loop through each bit in the byte. If it's set, add a pixel. */
				for(int k = 0; k < 8; k++)
					if((row & (1 << k)) != 0)
						charSprite.addPixel(new Sprite.Pixel(k, j, (byte) 0xFF));
			}

			spriteMap.put(i, charSprite);
		}
	}

	public void reset()
	{
		spriteMap = new HashMap<>();
		usedSpriteIDs = new boolean[256];
		boundSprite = 0xFF;
		boundSpriteExists = false;
		isNextTranslateNegative = false;

		/* Upload the default character sprites */
		for(int i = 0; i < initChars.length; i++)
		{
			usedSpriteIDs[i] = true;
			int[] currentChar = initChars[i];

			Sprite charSprite = new Sprite(this.panel);

			for(int j = 0; j < currentChar.length; j++)
			{
				byte row = (byte) (currentChar[j] & 0xFF);

				/* Loop through each bit in the byte. If it's set, add a pixel. */
				for(int k = 0; k < 8; k++)
					if((row & (1 << k)) != 0)
						charSprite.addPixel(new Sprite.Pixel(k, j, (byte) 0xFF));
			}

			spriteMap.put(i, charSprite);
		}
	}

	public void handle(JCPU cpu)
	{
		byte outZero = cpu.systemIO[1];
		byte outOne = cpu.systemIO[2];
		byte outTwo = cpu.systemIO[3];

		cpu.systemIO[6] = cpu.systemIO[0];

		System.out.println("Got command with ID " + cpu.systemIO[1]);

		switch(outZero)
		{
			case 0x01:
				int i = 0;
				while(usedSpriteIDs[i] && i != 255)
					i++;

				/* Return an error */
				if(i == 255)
				{
					cpu.systemIO[7] = (byte) 0xFF;
					break;
				}

				cpu.systemIO[7] = (byte) (i & 0xFF);

				spriteMap.put(i, new Sprite(panel));
				break;
			case 0x02:
				usedSpriteIDs[outOne & 0xFF] = false;

				if(spriteMap.containsKey(outOne & 0xFF))
					spriteMap.remove(outOne & 0xFF);
				break;
			case 0x03:
				boundSprite = outOne & 0xFF;
				boundSpriteExists = spriteMap.containsKey(boundSprite);
				break;
			case 0x04:
				boundSprite = 0xFF;
				boundSpriteExists = false;
				break;
			case 0x05:
				if(boundSpriteExists)
					pixelUploadX = (outOne << 8) | (outTwo);
				break;
			case 0x06:
				if(boundSpriteExists)
					pixelUploadY = (outOne << 8) | (outTwo);
				break;
			case 0x07:
				if(boundSpriteExists)
					spriteMap.get(boundSprite).addPixel(new Sprite.Pixel(pixelUploadX, pixelUploadY, outOne));
				break;
			case 0x08:
				cpu.systemIO[7] = (byte) (keyboardListener.hasNext() ? 0x01 : 0x00);
				break;
			case 0x09:
				if(keyboardListener.hasNext())
				{
					PiKeyboardListener.ExtendedKeyEvent event = keyboardListener.getNextEvent();
					cpu.systemIO[7] = (byte) (event.getEvent().getExtendedKeyCode() & 0xFF);
					cpu.systemIO[8] = (byte) (event.getType() == PiKeyboardListener.ExtendedKeyEvent.EventType.KEY_RELEASED ? 0x01 : 0x00);
				}
				break;
			case 0x0A:
				keyboardListener.clearBuffer();
				break;
			case 0x0B:
				panel.translationX += (isNextTranslateNegative ? -1 : 1) * ((outOne << 8) | (outTwo));
				break;
			case 0x0C:
				panel.translationY += (isNextTranslateNegative ? -1 : 1) * ((outOne << 8) | (outTwo));
				break;
			case 0x0D:
				panel.translationX = 0;
				panel.translationY = 0;
				break;
			case 0x0E:
				isNextTranslateNegative = outOne != 0;
				break;
			case 0x0F:
				addressHigh = (short) (((outOne << 8) | (outTwo)) & 0xFFFF);
				break;
			case 0x10:
				addressLow = (short) (((outOne << 8) | (outTwo)) & 0xFFFF);
				break;
			case 0x11:
				storageController.setAddress(addressHigh << 16 | addressLow);
				short storageData = storageController.read();
				cpu.systemIO[7] = (byte) ((storageData >> 8) & 0xFF);
				cpu.systemIO[8] = (byte) (storageData & 0xFF);
				break;
			case 0x12:
				storageController.setAddress(addressHigh << 16 | addressLow);
				storageController.write((short) (((outOne << 8) | (outTwo)) & 0xFFFF));
				break;
			case 0x13:
				short storageSize = storageController.getStorageSizeMiB();
				cpu.systemIO[7] = (byte) ((storageSize >> 8) & 0xFF);
				cpu.systemIO[8] = (byte) (storageSize & 0xFF);
				break;
			/* TODO: All other IO commands */
			case 0x17:
				short graphicsWidth = (short) GraphicsPanel.SCREEN_WIDTH;
				cpu.systemIO[7] = (byte) ((graphicsWidth >> 8) & 0xFF);
				cpu.systemIO[8] = (byte) (graphicsWidth & 0xFF);
				break;
			case 0x18:
				short graphicsHeight = (short) GraphicsPanel.SCREEN_HEIGHT;
				cpu.systemIO[7] = (byte) ((graphicsHeight >> 8) & 0xFF);
				cpu.systemIO[8] = (byte) (graphicsHeight & 0xFF);
				break;
			case 0x19:
				Graphics g = panel.getGraphicsPanel().getGraphics();
				g.setColor(Color.BLACK);
				g.drawRect(0, 0, GraphicsPanel.SCREEN_WIDTH, GraphicsPanel.SCREEN_HEIGHT);
				break;
			case 0x20:
				if(spriteMap.containsKey(new Integer(outOne & 0xFF)))
					spriteMap.get(new Integer(outOne & 0xFF)).draw();
				else
					System.out.println("Invalid sprite drawn with id " + (outOne & 0xFF));
				break;
			case 0x21:
				panel.overrideColor(outOne);
				break;
			case 0x22:
				panel.stopOverrideColor();
				break;
			case 0x23:
				panel.moveMem(((outOne & 0xFF) != 0 ? -1 : 1) * (outTwo & 0xFF), 0);
				break;
			case 0x24:
				panel.moveMem(0, ((outOne & 0xFF) != 0 ? -1 : 1) * (outTwo & 0xFF));
				break;
		}
	}

}
